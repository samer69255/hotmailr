#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('fbx2:server');
var http = require('http');
var cookie = require('cookie');

var request = require('request');

var unescapeJs = require("unescape-js");

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}

var io = require('socket.io')(server);
reset();

io.on('connection', (socket) => {
    console.log('connected');
    if (su.stat != 'stop') io.sockets.emit('run', {Ems:su.ems, stat:su.stat});
    socket.on('rest', () => {
        reset();
    })
    socket.on('start', async (emails) => {
        console.log(emails);
        reset();
        su.stat = 'working';
        io.sockets.emit('run', {stat:su.stat});
        io.sockets.emit('status', 'working');
        su.len = emails.length;
        await Init();
        for (var i in emails) {
            var email = emails[i];
            su.stat = email;
            io.sockets.emit('status', su.stat);
            await time(500);
            var ch = await ckeckH(email);
            console.log(email + ' => '+ ch);
            if (ch == 'error')
            {
                await(2000);
                try {
                    await Init();
                } catch (e) {
                    throw e;
            }
                i = i - 1;
                continue;
            }
            
            if (ch == true) {
                su.ems.push(email);
                su.t++;
                io.sockets.emit('add', email);
        }
         else if (ch == false) {  su.f++; }
         else su.u++;
        }
        su.stat = 'compile';
        io.sockets.emit('copm', {t:su.t, f:su.f, u:su.u, len:su.len});
    });
    
});



// functions

function reset() {
    ss = {}
         cookie = "";
         su = {ems:[], u:0, f:0, t:0, len:0, stat:'stop'};
         eml = "working";
}

function Init() {
    return new Promise(resolve => {
        
        
        request.get('https://signup.live.com/?lic=1', (err, respone, body) => {
            if (err) {
                console.log('initing ...');
                return Init();  };
            console.log('working');
    var uaid = body.match(/"uaid":"(.*?)"/)[1],
        uiflvr = body.match(/"uiflvr":(\d+)/)[1],
        scid = body.match(/"scid":(\d+)/)[1],
        hpgid = body.match(/"hpgid":(\d+)/)[1],
        canary = (body.match(/"apiCanary":"(.*?)"/)[1]);
    
    ss = {
        uaid:uaid,
        uiflvr:uiflvr,
        scid:scid,
        hpgid:hpgid,
        canary:unescapeJs(canary)
    }
    
    var Cookies = respone.headers['set-cookie'];
    Cookies.forEach(key => {
        var cc = key.split(' ')[0];
        cookie += " " + cc;
    });
    cookie = cookie.trim();
    //console.log(cookie);
    resolve();
        });
        

    });

}

async function ckeckH(email) {
    
    return new Promise(resolve => {
          var data = {signInName:email,uaid:ss.uaid,includeSuggestions:true,uiflvr:ss.uiflvr,scid:ss.scid,hpgid:ss.hpgid}
   // console.log(data);
    var options = {
    url:'https://signup.live.com/API/CheckAvailableSigninNames?lic=1',
    json:(data),
    headers:{
        'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8',
        'Cookie':cookie,
        'canary':ss.canary
}
}
    
    request.post(options, (err, response, body) => {
        if (err) {
            
            return resolve('int');
        }
        if (response.statusCode != '200') return resovle('error');
        if (body.apiCanary)
     ss.canary = body.apiCanary;
      resolve(body.isAvailable);
      //console.log(body);
    });
     
    });
  
}

async function time(dd) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve();
        },dd);
    });
}

