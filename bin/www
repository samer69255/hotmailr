#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('fbx2:server');
var http = require('http');
var Cookie = require('cookie');
var fs = require('fs');

var request = require('request');

var unescapeJs = require("unescape-js");

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
var Val = {};
var interval = null;
var io = require('socket.io')(server);

io.on('connection', (socket) => {
    console.log('connected');
    var cookies = Cookie.parse(socket.handshake.headers.cookie);
    var user = cookies.user;
    console.log(user);
    if (! Val[user]) reset(user);
    if (Val[user].stat != 'stop') {
        if (Val[user].stat == 'compile') var emails = fs.readFileSync('./users/'+Val[user].name+'.txt', 'UTF-8').split('\n'); else var emails = Val[user].ems;
        io.sockets.emit('run', {Ems:emails, stat:Val[user].stat}); 
    }
    socket.on('rest', () => {
        reset(user);
    })
    socket.on('start', async (emails) => {
        console.log(emails);
        reset(user);
//        interval = setInterval(() => {
//            request.get('https://htchkrn.herokuapp.com/', new Function())
//        },10 * 60 * 1000);
        Val[user].stat = 'working';
        socket.emit('run', {stat:Val[user].stat});
        socket.emit('status', 'working');
        Val[user].su.len = emails.length;
        await Init(user);
        for (var i in emails) {
            var email = emails[i];
            Val[user].stat = email;
            socket.emit('status', Val[user].stat);
            if (i > 0)
            await time(1000);
            var ch = await ckeckH(email, user);
            console.log(email + ' => '+ ch);
            if (ch == 'error')
            {
                await(2000);
                try {
                    await Init(user);
                } catch (e) {
                    throw e;
            }
                i = i - 1;
                continue;
            }
            
            if (ch == true) {
                Val[user].ems.push(email);
                Val[user].su.t++;
                socket.emit('add', email);
        }
         else if (ch == false) {  Val[user].su.f++; }
         else Val[user].su.u++;
        }
        Val[user].stat = 'compile';
        
            var name = 'user_'+(new Date).getTime().toFixed(0);
            fs.writeFile('./users/'+name+'.txt', Val[user].ems.join('\n'), function (e) {
                Val[user].ems = [];
                if (e) throw e;
            });
            Val[user].name = name;
        
        socket.emit('copm', {t:Val[user].su.t, f:Val[user].su.f, u:Val[user].su.u, len:Val[user].su.len});
    });
    
});



// functions
function reset(user) {
       Val[user] = {
           cookie:"",
           ss: {},
           su: {ems:[], u:0, f:0, t:0, len:0, stat:'stop'},
           stat: "stop",
           ems: []
           
       }
    console.log(Val[user]);
         if (interval != null) clearInterval(interval);
}

function Init(user) {
    return new Promise(resolve => {
        
        
        request.get('https://signup.live.com/?lic=1', (err, respone, body) => {
            if (err) {
                console.log('initing ...');
                return Init();  };
            console.log('working');
    var uaid = body.match(/"uaid":"(.*?)"/)[1],
        uiflvr = body.match(/"uiflvr":(\d+)/)[1],
        scid = body.match(/"scid":(\d+)/)[1],
        hpgid = body.match(/"hpgid":(\d+)/)[1],
        canary = (body.match(/"apiCanary":"(.*?)"/)[1]);
    
    Val[user].ss = {
        uaid:uaid,
        uiflvr:uiflvr,
        scid:scid,
        hpgid:hpgid,
        canary:unescapeJs(canary)
    }
    
    var Cookies = respone.headers['set-cookie'];
    Cookies.forEach(key => {
        var cc = key.split(' ')[0];
        Val[user].cookie += " " + cc;
    });
     Val[user].cookie =  Val[user].cookie.trim();
    //console.log(cookie);
    resolve();
        });
        

    });

}

async function ckeckH(email, user) {
    
    return new Promise(resolve => {
          var data = {signInName: email,uaid: Val[user].ss.uaid,includeSuggestions:true,uiflvr: Val[user].ss.uiflvr,scid: Val[user].ss.scid,hpgid: Val[user].ss.hpgid}
   // console.log(data);
    var options = {
    url:'https://signup.live.com/API/CheckAvailableSigninNames?lic=1',
    json:(data),
    headers:{
        'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8',
        'Cookie': Val[user].cookie,
        'canary': Val[user].ss.canary
}
}
    
    request.post(options, (err, response, body) => {
        if (err) {
            
            return resolve('int');
        }
        if (response.statusCode != '200') return resolve('error');
        if (body.apiCanary)
      Val[user].ss.canary = body.apiCanary;
      resolve(body.isAvailable);
      //console.log(body);
    });
     
    });
  
}

async function time(dd) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve();
        },dd);
    });
}

